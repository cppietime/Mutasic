tokens:
int := -?(0|[1-9][0-9]*)
float := -?( (0|[1-9][0-9]*)\.[0-9]* | \.[0-9]+ )
id := [a-zA-Z_][a-zA-Z_0-9]*
directive := #[^\n]*\n

operator precedence:
-!~
*/%
+-
<< >>
^|&
== != > < >= <=
&& ||

nonterminals:
<toplevel> -> directive | <vardecl> | <funcdef>
<vardecl> -> <type> id [ = <expr> ] { , id [ = <expr> ] };
<funcdef> -> <type> id ( [ <paramdecls> ] ) <block>
<paramdecls> -> <paramdecl> { , <paramdecl> }
<paramdecl> -> <type> id
<statement> -> <vardecl> | <expr> ; | <return> | <ifblock> | <forloop> | <whileloop> | <block>
<block> -> \{ {<statement>} \}
<return> -> return [ <expr> ] ;
<ifblock> -> if ( <expr> ) <statement> [ else <statement> ]
<forloop> -> for ( [ <statement> ] ; <expr> ; [ <statement> ] ) <statement>
<whileloop> -> while ( <expr> ) <statement>
<expr> -> <assignment> | <logic>
<assignment> -> <lvalue> asign_op { <lvalue> assign_op } <expr>
<lvalue> -> id | <expr> \[ <expr> \]
<funccall> -> id ( [ <args> ] )
<args> -> <expr> { , <expr> }
<logic> -> <comparison> { logic_op <comparison> }
<comparison> -> <bits> { comp_op <bits> }
<bits> -> <shift> { bit_op <shift> }
<shift> -> <addition> { shift_op <addition> }
<addition> -> <multiplication> { add_op <multiplication> }
<multiplication> -> <unary> { mul_op <unary> }
<unary> -> [ unary_op ] <value>
<value> -> ( <expr> ) | id | literal | funccall

LL?:
PROGRAM = TOPLEVEL*;
TOPLEVEL = TYPE, id, ( [ ASSRHS, { comma, id, ASSRHS } ], semicolon | PARAMSLIST, BLOCK );
TYPE = id, [ lbrack, rbrack ];
ASSRHS = assign, EXPR;
PARAMSLIST = lparen, [ TYPE, id, { comma, TYPE, id } ], rparen;
BLOCK = lbrace, { STMT }, rbrace;
EXPR = LOGIC, { assign, LOGIC };
LOGIC = COMPARISON, { logop, COMPARISON };
COMPARISON = BITS, { compop, BITS };
BITS = SHIFT, { bitop, SHIFT };
SHIFT = ADDITION, { shiftop, ADDITION };
ADDITION = MULTIPLY, { addop, MULTIPLY };
MULTIPLY = UNARY, { mulop, UNARY };
UNARY = { addop }, VALUE;
VALUE = literal | ( lparen, EXPR, rparen | id ), { lparen, [ ARGSLIST ], rparen | lbrack, EXPR, rbrack };
ARGSLIST = EXPR, { comma, EXPR };
STMT = EXPR, semicolon | IFBLOCK | WHILELOOP | FORLOOP | BLOCK | semicolon;
IFBLOCK = if, lparen, EXPR, rparen, STMT, [ ELSE, STMT ];
WHILELOOP = while, lparen, EXPR, rparen, STMT;
FORLOOP = for, lparen, STMT, EXPR, semicolon, STMT, rparen, STMT;
